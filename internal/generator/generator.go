package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"sort"
	"strings"

	"github.com/emicklei/proto"
)

type Generator struct {
	def *proto.Proto

	buf bytes.Buffer

	version   int
	gopackage string
	messages  []*Message

	Options struct {
		GenGetter  bool
		GenSize    bool
		GenMarshal bool
	}
}

func New(def *proto.Proto) *Generator {
	g := &Generator{
		def:     def,
		version: 2,
	}
	g.parse()

	sort.Slice(g.messages, func(i, j int) bool {
		return g.messages[i].Name < g.messages[j].Name
	})

	return g
}

func (g *Generator) Pln(args ...interface{}) { _, _ = fmt.Fprintln(&g.buf, args...) }
func (g *Generator) Pf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) Generate(out io.Writer) {
	g.generate()

	source, err := format.Source(g.buf.Bytes())
	if err != nil {
		fmt.Printf("%s", g.buf.Bytes())
		panic(err)
	}
	_, err = out.Write(source)
	if err != nil {
		panic(err)
	}
}

func (g *Generator) parse() {
	for _, elem := range g.def.Elements {
		switch elem := elem.(type) {
		case *proto.Syntax:
			switch elem.Value {
			case "proto3":
				g.version = 3
			case "proto2":
				g.version = 2
			default:
				panic("unsupported syntax")
			}
		case *proto.Option:
			if elem.Name == "go_package" {
				p := elem.Constant.Source
				g.gopackage = strings.TrimPrefix(p, "./;")
			}
		case *proto.Message:
			g.message(elem)
		}
	}
}

func (g *Generator) lookup(name string) *Message {
	for _, m := range g.messages {
		if m.Name == name {
			return m
		}
	}
	m := &Message{Name: name}
	g.messages = append(g.messages, m)
	return m
}

func (g *Generator) message(m *proto.Message) {
	msg := g.lookup(m.Name)
	for _, field := range m.Elements {
		switch field := field.(type) {
		case *proto.NormalField:
			f := &Field{
				Name:     field.Name,
				Sequence: field.Sequence,
				Type:     g.typ(field.Type),
				Option:   FNone,
			}

			switch {
			case field.Repeated:
				f.Option = FRepeated
			case field.Optional:
				f.Option = FOptional
			case field.Required:
				f.Option = FRequired
			}
			msg.Fields = append(msg.Fields, f)
		case *proto.Message:
			panic("nested message not implemented")
		}
	}
	sort.Slice(msg.Fields, func(i, j int) bool {
		return msg.Fields[i].Sequence < msg.Fields[j].Sequence
	})
}
func (g *Generator) generate() {
	g.Pln("// Code generated by yaprotoc. DO NOT EDIT.")
	g.Pln()
	g.Pln("package ", g.gopackage)
	g.Pln()

	if g.Options.GenSize || g.Options.GenMarshal {
		g.Pln("import proto \"github.com/wdvxdr1123/yaproto\"")
		g.Pln()
	}

	g.Pln()

	for _, m := range g.messages {
		g.Pln("type ", m.GoType(), " struct {")
		for _, f := range m.Fields {
			switch f.Option {
			case FNone, FRepeated:
				g.Pf("%s %s `protobuf:\"%d\"`\n", f.GoName(), f.GoType(), f.Sequence)
			case FRequired:
				g.Pf("%s %s `protobuf:\"%d,req\"`\n", f.GoName(), f.GoType(), f.Sequence)
			case FOptional:
				g.Pf("%s %s `protobuf:\"%d,opt\"`\n", f.GoName(), f.GoType(), f.Sequence)
			}

		}
		g.Pln("}")
		g.Pln()

		if g.Options.GenGetter {
			g.getter(m)
		}
		if g.Options.GenSize {
			g.size(m)
		}
	}
}

func (g *Generator) getter(m *Message) {
	for _, f := range m.Fields {
		g.Pln()
		g.Pf("func (x *%s) Get%s() %s {\n", m.GoType(), f.GoName(), f.GoType())
		g.Pln("    if x != nil {")
		g.Pf("        return x.%s\n", f.GoName())
		g.Pln("    }")
		g.Pln("    return", f.DefaultValue())
		g.Pln("}")
		g.Pln()
	}
}

func (g *Generator) size(m *Message) {
	g.Pf("func (x *%s) Size() (n int) {\n", m.GoType())
	g.Pln("    if x == nil {")
	g.Pln("        return 0")
	g.Pln("    }")
	g.Pln("    var l int")
	g.Pln("    _ = l")

	var repeated bool
	fixed := func(size int, field *Field) {
		if repeated {
			g.Pf("n += %d*len(x.%s)\n", size, field.GoName())
		} else {
			g.Pln("n +=", size)
		}
	}

	for _, field := range m.Fields {
		repeated = field.Option == FRepeated
		switch field.Type.Scope() {
		case SBuiltin:
			typ := field.Type.(BuiltinType)
			ks := keySize(field.Sequence, typ.WireType())
			switch typ.WireType() {
			case WireVarint:
				switch typ.Name() {
				case "uint64":
					if repeated {
						g.Pf("for _,e := range x.%s {\n", field.GoName())
						g.Pf("    n += %d + proto.VarintSize(e)\n", ks)
						g.Pln("}")
					} else {
						g.Pf("n += %d + proto.VarintSize(x.%s)\n", ks, field.GoName())
					}

				case "bool":
					fixed(ks+1, field)

				default:
					if repeated {
						g.Pf("for _,e := range x.%s {\n", field.GoName())
						g.Pf("    n += %d + proto.VarintSize(uint64(e))\n", ks)
						g.Pln("}")
					} else {
						g.Pf("n += %d + proto.VarintSize(uint64(x.%s))\n", ks, field.GoName())
					}
				}

			case WireFixed32:
				fixed(ks+4, field)

			case WireFixed64:
				fixed(ks+8, field)

			case WireBytes:
				if repeated {
					g.Pf("for _, b := range x.%s {\n", field.GoName())
					g.Pln("    l = len(b)")
					g.Pf("     n += %d + proto.VarintSize(uint64(l)) + l\n", ks)
					g.Pln("}")
				} else if g.Proto3() {
					g.Pf("l = len(x.%s)\n", field.GoName())
					g.Pln("if l>0 {\n")
					g.Pf("    n += %d + proto.VarintSize(uint64(l)) + l\n", ks)
					g.Pln("}")
				} else {
					g.Pf("l = len(x.%s)\n", field.GoName())
					g.Pf("n += %d + proto.VarintSize(uint64(l)) + l\n", ks)
				}
			}

		case SMessage:
			ks := keySize(field.Sequence, WireBytes)
			if repeated {
				g.Pf("for _, e := range x.%s {\n", field.GoName())
				g.Pln("    l = e.Size()")
				g.Pf("     n += %d + proto.VarintSize(uint64(l)) + l\n", ks)
				g.Pln("}")
			} else {
				g.Pf("if e := x.%s;e != nil {\n", field.GoName())
				g.Pln("    l = e.Size()")
				g.Pf("    n += %d + proto.VarintSize(uint64(l)) + l\n", ks)
				g.Pln("}")
			}
		}
	}

	g.Pln("return")
	g.Pln("}")
}

func (g *Generator) Proto3() bool {
	return g.version == 3
}
