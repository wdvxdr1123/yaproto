package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"sort"
	"strings"

	"github.com/emicklei/proto"
)

type Generator struct {
	def *proto.Proto

	buf bytes.Buffer

	version   int
	gopackage string
	messages  []*Message

	Options struct {
		GenGetter  bool
		GenSize    bool
		GenMarshal bool
	}
}

func New(def *proto.Proto) *Generator {
	g := &Generator{
		def:     def,
		version: 2,
	}
	g.parse()

	sort.Slice(g.messages, func(i, j int) bool {
		return g.messages[i].Name < g.messages[j].Name
	})

	return g
}

func (g *Generator) Pln(args ...interface{}) { _, _ = fmt.Fprintln(&g.buf, args...) }
func (g *Generator) Pf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) Generate(out io.Writer) {
	g.generate()

	source, err := format.Source(g.buf.Bytes())
	if err != nil {
		fmt.Printf("%s", g.buf.Bytes())
		panic(err)
	}
	_, err = out.Write(source)
	if err != nil {
		panic(err)
	}
}

func (g *Generator) parse() {
	for _, elem := range g.def.Elements {
		switch elem := elem.(type) {
		case *proto.Syntax:
			switch elem.Value {
			case "proto3":
				g.version = 3
			case "proto2":
				g.version = 2
			default:
				panic("unsupported syntax version")
			}
		case *proto.Option:
			if elem.Name == "go_package" {
				p := elem.Constant.Source
				g.gopackage = strings.TrimPrefix(p, "./;")
			}
		case *proto.Message:
			g.message(elem)
		}
	}
}

func (g *Generator) lookup(name string) *Message {
	for _, m := range g.messages {
		if m.Name == name {
			return m
		}
	}
	m := &Message{Name: name}
	g.messages = append(g.messages, m)
	return m
}

func (g *Generator) message(m *proto.Message) {
	msg := g.lookup(m.Name)
	for _, field := range m.Elements {
		switch field := field.(type) {
		case *proto.NormalField:
			f := &Field{
				Name:     field.Name,
				Sequence: field.Sequence,
				Type:     g.typ(field.Type),
			}

			switch {
			case field.Repeated:
				f.Flag.Set(FRepeated, true)
			case field.Optional:
				f.Flag.Set(FOptional, true)
			case field.Required:
				f.Flag.Set(FRequired, true)
			}

			if !f.IsRepeated() {
				if (g.proto2() && f.Type.Name() != "bytes") ||
					(g.proto3() && f.Type.Scope() == SMessage) {
					f.Set(FPtr, true)
				}
			}

			msg.Fields = append(msg.Fields, f)
		case *proto.Message:
			panic("nested message not implemented")
		}
	}
	sort.Slice(msg.Fields, func(i, j int) bool {
		return msg.Fields[i].Sequence < msg.Fields[j].Sequence
	})
}
func (g *Generator) generate() {
	g.Pln("// Code generated by yaprotoc. DO NOT EDIT.")
	g.Pln()
	g.Pln("package ", g.gopackage)
	g.Pln()

	if g.Options.GenSize || g.Options.GenMarshal {
		g.Pln("import (")
		g.Pln("    proto \"github.com/wdvxdr1123/yaproto\"")
		if g.Options.GenMarshal {
			// g.Pln("\"encoding/binary\"")
		}
		g.Pln(")")
		g.Pln()
	}

	g.Pln()

	for _, m := range g.messages {
		g.Pln("type ", m.GoType(), " struct {")
		for _, f := range m.Fields {
			switch {
			case f.Is(FRequired):
				g.Pf("%s %s `protobuf:\"%d,req\"`\n", f.GoName(), f.ftype(), f.Sequence)
			case f.Is(FOptional):
				g.Pf("%s %s `protobuf:\"%d,opt\"`\n", f.GoName(), f.ftype(), f.Sequence)
			default:
				g.Pf("%s %s `protobuf:\"%d\"`\n", f.GoName(), f.ftype(), f.Sequence)
			}
		}
		g.Pln("}")
		g.Pln()

		if g.Options.GenGetter {
			g.getter(m)
		}
		if g.Options.GenSize {
			g.size(m)
		}
		if g.Options.GenMarshal {
			g.marshal(m)
		}
	}
}

func (g *Generator) proto2() bool { return g.version == 2 }
func (g *Generator) proto3() bool { return g.version == 3 }

func conv(x string, src, dst Type) string {
	if dst != src {
		x = dst.GoType() + "(" + x + ")"
	}
	return x
}
