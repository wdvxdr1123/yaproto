package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"path"
	"reflect"
	"sort"
	"strconv"

	"github.com/wdvxdr1123/yaproto/internal/importer"
	"github.com/wdvxdr1123/yaproto/internal/types"
)

type GoPackage struct {
	Path  string
	Alias string
}

type Generator struct {
	buf *bytes.Buffer

	Pkg      *importer.Package
	imported map[string]*importer.Package
	goImport map[GoPackage]bool

	Options struct {
		// GenGetter:
		//	0: disabled
		//	1: generate getters for pointer fields
		//	2: generate getters for all fields
		GenGetter int
		// GenMarshal:
		//	0: disabled
		//	1: generate Marshal helper
		//	2: generate Marshal specific methods without reflection
		GenMarshal int
		GenSize    bool
	}
}

func New(pkg *importer.Package) *Generator {
	g := &Generator{
		Pkg:      pkg,
		goImport: make(map[GoPackage]bool),
		imported: make(map[string]*importer.Package),
	}

	for _, packagePath := range g.Pkg.Imported {
		p, err := importer.Import(packagePath)
		if err != nil {
			panic(err)
		}
		g.imported[p.Package] = p
		g.importGoPackage(path.Join(importer.ProtoPath, p.OutputPath), p.GoPackage)
	}

	return g
}

func (g *Generator) Pln(args ...interface{}) { _, _ = fmt.Fprintln(g.buf, args...) }
func (g *Generator) Pf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(g.buf, format, args...)
}

func (g *Generator) Generate(out io.Writer) {
	body := new(bytes.Buffer)
	g.generate(body)
	buf := new(bytes.Buffer)
	g.header(buf)
	_, _ = io.Copy(buf, body)

	source, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("%s", buf.Bytes())
		panic(err)
	}
	_, err = out.Write(source)
	if err != nil {
		println(reflect.TypeOf(err).String())
		panic(err)
	}
}

func (g *Generator) header(buffer *bytes.Buffer) {
	g.buf = buffer
	g.Pf("// Code generated by yaprotoc. DO NOT EDIT.\n")
	g.Pf("// source: %s\n", g.Pkg.Proto.Filename)
	g.Pf("\n")
	g.Pf("package %s\n", g.Pkg.GoPackage)
	g.Pf("\n")

	if len(g.goImport) > 0 {
		g.Pf("import (\n")
		var imports []GoPackage
		for p, ok := range g.goImport {
			if ok {
				imports = append(imports, p)
			}
		}
		sort.Slice(imports, func(i, j int) bool {
			return imports[i].Path < imports[j].Path
		})
		for _, p := range imports {
			g.Pf("%s %s\n", p.Alias, strconv.Quote(p.Path))
		}
		g.Pln(")\n")
	}
}

func (g *Generator) generate(buffer *bytes.Buffer) {
	g.buf = buffer
	objects := g.mergeScope()

	if g.Options.GenMarshal == 1 {
		g.importGoPackage("github.com/segmentio/encoding/proto", "")
		g.importGoPackage("github.com/pkg/errors", "")
	}

	for _, obj := range objects {
		switch obj := obj.Obj.(type) {
		case *types.Message:
			sort.Slice(obj.Fields, func(i, j int) bool {
				return obj.Fields[i].Sequence < obj.Fields[j].Sequence
			})
			g.generateMessage(obj)
		case *types.Enum:
			g.generateEnum(obj)
		}
	}
}

func (g *Generator) mergeScope() []*types.Object {
	objects := make([]*types.Object, 0)
	var visit func(*types.Scope)
	visit = func(s *types.Scope) {
		// merge all children scope
		for _, child := range s.Children {
			visit(child)
		}
		// add all elems
		for _, obj := range s.Elems {
			objects = append(objects, obj)
		}
	}
	visit(g.Pkg.Universe)

	sort.Slice(objects, func(i, j int) bool {
		return objects[i].GoType() < objects[j].GoType()
	})

	return objects
}

func (g *Generator) generateMessage(m *types.Message) {
	g.Pln("type ", m.GoType(), " struct {")
	for _, f := range m.Fields {
		switch {
		case f.Is(types.FRepeated):
			g.Pf("%s %s `protobuf:\"%s,%d,rep\"`\n", f.GoName(), f.Ftype(), types.WireString(f.Type), f.Sequence)
		default:
			g.Pf("%s %s `protobuf:\"%s,%d,opt\"`\n", f.GoName(), f.Ftype(), types.WireString(f.Type), f.Sequence)
		}
	}
	g.Pln("}")
	g.Pln()

	if g.Options.GenGetter > 0 {
		g.getter(m)
	}
	if g.Options.GenSize {
		g.size(m)
	}
	if g.Options.GenMarshal > 0 {
		g.marshal(m)
	}
}

func (g *Generator) generateEnum(enum *types.Enum) {
	g.Pf("type %s int32\n", enum.GoType())
	g.Pln()
	if len(enum.Fields) > 0 {
		g.Pln("const (\n")
		for _, field := range enum.Fields {
			g.Pf("%s_%s %s = %d\n", enum.GoType(), field.Name, enum.GoType(), field.Value)
		}
		g.Pln(")\n")
	}

	g.Pf(`func (x %s) Enum() *%s {
	p := new(%s)
	*p = x
	return p
}`, enum.GoType(), enum.GoType(), enum.GoType())
	g.Pln()
}

func (g *Generator) proto2() bool { return g.Pkg.Version == 2 }
func (g *Generator) proto3() bool { return g.Pkg.Version == 3 }

func (g *Generator) importGoPackage(path, alias string) {
	g.goImport[GoPackage{path, alias}] = true
}
